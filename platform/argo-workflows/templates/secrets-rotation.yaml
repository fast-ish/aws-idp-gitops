# =============================================================================
# SECRETS ROTATION WORKFLOW
# =============================================================================
# Automated workflow for rotating secrets in AWS Secrets Manager.
# Triggers pod restart after rotation to pick up new credentials.
#
# Rotation Types:
# - Database credentials (RDS automatic rotation)
# - API keys (custom Lambda rotation)
# - Service accounts (manual + workflow)
# =============================================================================
apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: secrets-rotation
  namespace: argo
  labels:
    app.kubernetes.io/name: secrets-rotation
    app.kubernetes.io/component: workflow-template
spec:
  entrypoint: rotate-secrets
  serviceAccountName: argo-workflow
  arguments:
    parameters:
      - name: secret-name
        description: "AWS Secrets Manager secret name"
      - name: app
        description: "Application that uses this secret"
      - name: namespace
        description: "Kubernetes namespace"
      - name: rotation-type
        description: "Type: database, api-key, service-account"
        default: "api-key"
      - name: restart-pods
        description: "Restart pods after rotation"
        default: "true"

  templates:
    # =========================================================================
    # MAIN ROTATION WORKFLOW
    # =========================================================================
    - name: rotate-secrets
      dag:
        tasks:
          # Validate secret exists
          - name: validate
            template: validate-secret
            arguments:
              parameters:
                - name: secret-name
                  value: "{{workflow.parameters.secret-name}}"

          # Trigger AWS rotation
          - name: trigger-rotation
            template: trigger-aws-rotation
            dependencies: [validate]
            arguments:
              parameters:
                - name: secret-name
                  value: "{{workflow.parameters.secret-name}}"
                - name: rotation-type
                  value: "{{workflow.parameters.rotation-type}}"

          # Wait for rotation to complete
          - name: wait-rotation
            template: wait-for-rotation
            dependencies: [trigger-rotation]
            arguments:
              parameters:
                - name: secret-name
                  value: "{{workflow.parameters.secret-name}}"

          # Force External Secrets refresh
          - name: refresh-external-secret
            template: refresh-k8s-secret
            dependencies: [wait-rotation]
            arguments:
              parameters:
                - name: app
                  value: "{{workflow.parameters.app}}"
                - name: namespace
                  value: "{{workflow.parameters.namespace}}"

          # Restart pods to pick up new credentials
          - name: restart-pods
            template: rolling-restart
            dependencies: [refresh-external-secret]
            when: "{{workflow.parameters.restart-pods}} == true"
            arguments:
              parameters:
                - name: app
                  value: "{{workflow.parameters.app}}"
                - name: namespace
                  value: "{{workflow.parameters.namespace}}"

          # Verify application health
          - name: verify-health
            template: verify-app-health
            dependencies: [restart-pods]
            arguments:
              parameters:
                - name: app
                  value: "{{workflow.parameters.app}}"
                - name: namespace
                  value: "{{workflow.parameters.namespace}}"

          # Send notification
          - name: notify
            template: send-notification
            dependencies: [verify-health]
            arguments:
              parameters:
                - name: secret-name
                  value: "{{workflow.parameters.secret-name}}"
                - name: app
                  value: "{{workflow.parameters.app}}"
                - name: status
                  value: "{{tasks.verify-health.outputs.parameters.status}}"

    # =========================================================================
    # VALIDATE SECRET EXISTS
    # =========================================================================
    - name: validate-secret
      inputs:
        parameters:
          - name: secret-name
      script:
        image: amazon/aws-cli:2.15.0
        env:
          - name: AWS_REGION
            value: us-west-2
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          SECRET_NAME="{{inputs.parameters.secret-name}}"

          echo "Validating secret: $SECRET_NAME"

          # Check if secret exists
          aws secretsmanager describe-secret \
            --secret-id "$SECRET_NAME" \
            --query 'Name' \
            --output text

          echo "Secret validated successfully"

    # =========================================================================
    # TRIGGER AWS ROTATION
    # =========================================================================
    - name: trigger-aws-rotation
      inputs:
        parameters:
          - name: secret-name
          - name: rotation-type
      script:
        image: amazon/aws-cli:2.15.0
        env:
          - name: AWS_REGION
            value: us-west-2
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          SECRET_NAME="{{inputs.parameters.secret-name}}"
          ROTATION_TYPE="{{inputs.parameters.rotation-type}}"

          echo "Triggering rotation for: $SECRET_NAME (type: $ROTATION_TYPE)"

          # Check if rotation is already configured
          ROTATION_ENABLED=$(aws secretsmanager describe-secret \
            --secret-id "$SECRET_NAME" \
            --query 'RotationEnabled' \
            --output text 2>/dev/null || echo "False")

          if [ "$ROTATION_ENABLED" = "True" ]; then
            echo "Rotation is configured, triggering immediate rotation..."
            aws secretsmanager rotate-secret \
              --secret-id "$SECRET_NAME" \
              --rotation-lambda-arn "$(aws secretsmanager describe-secret \
                --secret-id "$SECRET_NAME" \
                --query 'RotationLambdaARN' \
                --output text)"
          else
            echo "Rotation not configured for this secret"
            echo "Creating new version manually..."

            case "$ROTATION_TYPE" in
              api-key)
                # For API keys, generate new random value
                NEW_VALUE=$(openssl rand -base64 32)
                aws secretsmanager put-secret-value \
                  --secret-id "$SECRET_NAME" \
                  --secret-string "$NEW_VALUE"
                ;;
              *)
                echo "Manual rotation not supported for type: $ROTATION_TYPE"
                echo "Please configure AWS Secrets Manager rotation"
                exit 1
                ;;
            esac
          fi

          echo "Rotation triggered successfully"

    # =========================================================================
    # WAIT FOR ROTATION TO COMPLETE
    # =========================================================================
    - name: wait-for-rotation
      inputs:
        parameters:
          - name: secret-name
      script:
        image: amazon/aws-cli:2.15.0
        env:
          - name: AWS_REGION
            value: us-west-2
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          SECRET_NAME="{{inputs.parameters.secret-name}}"
          MAX_ATTEMPTS=30
          ATTEMPT=0

          echo "Waiting for rotation to complete..."

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            # Check rotation status
            VERSIONS=$(aws secretsmanager list-secret-version-ids \
              --secret-id "$SECRET_NAME" \
              --query 'Versions[?contains(VersionStages, `AWSCURRENT`)].VersionId' \
              --output text)

            # Check if there's a pending version
            PENDING=$(aws secretsmanager list-secret-version-ids \
              --secret-id "$SECRET_NAME" \
              --query 'Versions[?contains(VersionStages, `AWSPENDING`)].VersionId' \
              --output text)

            if [ -z "$PENDING" ]; then
              echo "Rotation completed. Current version: $VERSIONS"
              exit 0
            fi

            echo "Rotation in progress... (attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS)"
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done

          echo "Timeout waiting for rotation"
          exit 1

    # =========================================================================
    # REFRESH KUBERNETES SECRET
    # =========================================================================
    - name: refresh-k8s-secret
      inputs:
        parameters:
          - name: app
          - name: namespace
      script:
        image: bitnami/kubectl:1.29
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          APP="{{inputs.parameters.app}}"
          NAMESPACE="{{inputs.parameters.namespace}}"

          echo "Refreshing ExternalSecret for $APP in $NAMESPACE"

          # Get ExternalSecret name
          ES_NAME=$(kubectl get externalsecret -n "$NAMESPACE" \
            -l "app.kubernetes.io/name=$APP" \
            -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

          if [ -z "$ES_NAME" ]; then
            ES_NAME="${APP}-secrets"
          fi

          echo "Triggering refresh for ExternalSecret: $ES_NAME"

          # Force refresh by updating annotation
          kubectl annotate externalsecret "$ES_NAME" -n "$NAMESPACE" \
            fasti.sh/last-refresh="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite

          # Wait for sync
          echo "Waiting for ExternalSecret to sync..."
          sleep 30

          # Verify secret was updated
          SECRET_AGE=$(kubectl get secret "${ES_NAME}" -n "$NAMESPACE" \
            -o jsonpath='{.metadata.creationTimestamp}' 2>/dev/null || echo "")

          echo "Secret updated. Timestamp: $SECRET_AGE"

    # =========================================================================
    # ROLLING RESTART
    # =========================================================================
    - name: rolling-restart
      inputs:
        parameters:
          - name: app
          - name: namespace
      script:
        image: bitnami/kubectl:1.29
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          APP="{{inputs.parameters.app}}"
          NAMESPACE="{{inputs.parameters.namespace}}"

          echo "Performing rolling restart for $APP in $NAMESPACE"

          # Try Rollout first (Argo Rollouts)
          if kubectl get rollout "$APP" -n "$NAMESPACE" &>/dev/null; then
            echo "Found Argo Rollout, triggering restart..."
            kubectl patch rollout "$APP" -n "$NAMESPACE" \
              -p "{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"fasti.sh/secret-rotation\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}}}}}" \
              --type merge
          # Try Deployment
          elif kubectl get deployment "$APP" -n "$NAMESPACE" &>/dev/null; then
            echo "Found Deployment, triggering restart..."
            kubectl rollout restart deployment "$APP" -n "$NAMESPACE"
          else
            echo "No Rollout or Deployment found for $APP"
            exit 1
          fi

          echo "Rolling restart initiated"

          # Wait for rollout
          echo "Waiting for rollout to complete..."
          kubectl rollout status deployment "$APP" -n "$NAMESPACE" --timeout=300s 2>/dev/null || \
            kubectl rollout status rollout "$APP" -n "$NAMESPACE" --timeout=300s 2>/dev/null || true

    # =========================================================================
    # VERIFY APPLICATION HEALTH
    # =========================================================================
    - name: verify-app-health
      inputs:
        parameters:
          - name: app
          - name: namespace
      outputs:
        parameters:
          - name: status
            valueFrom:
              path: /tmp/status
      script:
        image: bitnami/kubectl:1.29
        command: [bash]
        source: |
          #!/bin/bash
          set -e

          APP="{{inputs.parameters.app}}"
          NAMESPACE="{{inputs.parameters.namespace}}"

          echo "Verifying health for $APP in $NAMESPACE"

          # Wait for pods to be ready
          sleep 30

          # Check pod status
          READY=$(kubectl get pods -n "$NAMESPACE" \
            -l "app.kubernetes.io/name=$APP" \
            -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | grep -c "True" || echo "0")

          TOTAL=$(kubectl get pods -n "$NAMESPACE" \
            -l "app.kubernetes.io/name=$APP" \
            --no-headers | wc -l | tr -d ' ')

          if [ "$READY" -eq "$TOTAL" ] && [ "$TOTAL" -gt 0 ]; then
            echo "success" > /tmp/status
            echo "‚úì All pods healthy ($READY/$TOTAL)"
          else
            echo "failed" > /tmp/status
            echo "‚úó Pods not healthy ($READY/$TOTAL)"
            exit 1
          fi

    # =========================================================================
    # SEND NOTIFICATION
    # =========================================================================
    - name: send-notification
      inputs:
        parameters:
          - name: secret-name
          - name: app
          - name: status
      script:
        image: curlimages/curl:8.5.0
        env:
          - name: SLACK_WEBHOOK_URL
            valueFrom:
              secretKeyRef:
                name: slack-webhook
                key: url
                optional: true
        command: [sh]
        source: |
          #!/bin/sh

          SECRET_NAME="{{inputs.parameters.secret-name}}"
          APP="{{inputs.parameters.app}}"
          STATUS="{{inputs.parameters.status}}"

          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "Slack not configured, logging locally"
            echo "Secret: $SECRET_NAME"
            echo "App: $APP"
            echo "Status: $STATUS"
            exit 0
          fi

          if [ "$STATUS" = "success" ]; then
            EMOJI="üîê"
            COLOR="good"
            MSG="Secret rotation completed successfully"
          else
            EMOJI="‚ö†Ô∏è"
            COLOR="danger"
            MSG="Secret rotation completed with issues"
          fi

          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{
              \"attachments\": [{
                \"color\": \"${COLOR}\",
                \"blocks\": [
                  {
                    \"type\": \"section\",
                    \"text\": {
                      \"type\": \"mrkdwn\",
                      \"text\": \"${EMOJI} *${MSG}*\n*Secret:* \`${SECRET_NAME}\`\n*Application:* ${APP}\n*Status:* ${STATUS}\"
                    }
                  }
                ]
              }]
            }"
---
# =============================================================================
# SCHEDULED SECRET ROTATION
# =============================================================================
# CronWorkflow for scheduled rotation of secrets
# =============================================================================
apiVersion: argoproj.io/v1alpha1
kind: CronWorkflow
metadata:
  name: scheduled-secret-rotation
  namespace: argo
  labels:
    app.kubernetes.io/name: scheduled-secret-rotation
spec:
  # Run every Sunday at 2 AM UTC
  schedule: "0 2 * * 0"
  timezone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  workflowSpec:
    entrypoint: rotate-all
    serviceAccountName: argo-workflow
    templates:
      - name: rotate-all
        dag:
          tasks:
            - name: list-secrets
              template: list-rotatable-secrets

            - name: rotate-secrets
              template: rotate-single-secret
              dependencies: [list-secrets]
              arguments:
                parameters:
                  - name: secret-info
                    value: "{{item}}"
              withParam: "{{tasks.list-secrets.outputs.result}}"

      - name: list-rotatable-secrets
        script:
          image: bitnami/kubectl:1.29
          command: [bash]
          source: |
            #!/bin/bash
            # List all ExternalSecrets with rotation enabled
            kubectl get externalsecret --all-namespaces \
              -l fasti.sh/secret-rotation=enabled \
              -o json | \
              jq -c '[.items[] | {name: .metadata.name, namespace: .metadata.namespace, app: .metadata.labels["app.kubernetes.io/name"]}]'

      - name: rotate-single-secret
        inputs:
          parameters:
            - name: secret-info
        script:
          image: bitnami/kubectl:1.29
          command: [bash]
          source: |
            #!/bin/bash
            INFO='{{inputs.parameters.secret-info}}'
            NAME=$(echo "$INFO" | jq -r '.name')
            NAMESPACE=$(echo "$INFO" | jq -r '.namespace')
            APP=$(echo "$INFO" | jq -r '.app')

            echo "Would rotate: $NAME in $NAMESPACE for app $APP"
            # Actual rotation would trigger the secrets-rotation workflow
---
# =============================================================================
# EXPIRING SECRETS ALERT
# =============================================================================
# Sensor to detect and alert on expiring secrets
# =============================================================================
apiVersion: argoproj.io/v1alpha1
kind: Sensor
metadata:
  name: secret-expiry-monitor
  namespace: argo-events
spec:
  template:
    serviceAccountName: argo-events-sa
  dependencies:
    - name: cron-check
      eventSourceName: calendar
      eventName: secret-expiry-check
  triggers:
    - template:
        name: check-expiring-secrets
        argoWorkflow:
          operation: submit
          source:
            resource:
              apiVersion: argoproj.io/v1alpha1
              kind: Workflow
              metadata:
                generateName: check-secret-expiry-
                namespace: argo
              spec:
                entrypoint: check
                serviceAccountName: argo-workflow
                templates:
                  - name: check
                    script:
                      image: amazon/aws-cli:2.15.0
                      env:
                        - name: AWS_REGION
                          value: us-west-2
                      command: [bash]
                      source: |
                        #!/bin/bash
                        # List secrets and check for upcoming rotation
                        aws secretsmanager list-secrets \
                          --filter Key=tag-key,Values=fasti.sh/managed \
                          --query 'SecretList[*].[Name,LastRotatedDate]' \
                          --output table
